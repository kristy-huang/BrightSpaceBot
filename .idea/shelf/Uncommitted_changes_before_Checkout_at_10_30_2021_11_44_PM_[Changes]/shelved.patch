Index: discord_bot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Our discord token is saved in another file for security\r\nfrom discord_config import config, USERNAME, PIN\r\nimport discord\r\nfrom discord.ext import tasks, commands\r\nimport asyncio\r\nfrom file_storage import *\r\nimport datetime\r\nimport threading\r\n\r\nfrom bs_utilities import BSUtilities\r\nimport threading\r\nfrom database.db_utilities import DBUtilities\r\n\r\n'''\r\nTo add the bot to your own server and test it out, copy this URL into your browser\r\nhttps://discord.com/api/oauth2/authorize?client_id=894695859567083520&permissions=534723950656&scope=bot\r\n '''\r\n\r\n# This will be our discord client. From here we will get our input\r\nclient = discord.Client()\r\nchannelID = 663863991218733058  # mine!\r\n# TODO save this in the database - right now this is my (Raveena's) channel\r\n\r\ndb_config = \"./database/db_config.py\"\r\nBS_UTILS = BSUtilities()\r\nDB_UTILS = DBUtilities(db_config)\r\n\r\nauthor_id_to_username_map = {}\r\n\r\n\r\n# Having the bot log in and be online\r\n@client.event\r\nasync def on_ready():\r\n    BS_UTILS.set_session(USERNAME, PIN)\r\n\r\n    print(\"We have logged in as: \" + str(client.user))\r\n\r\n\r\n@commands.command()\r\nasync def quit(ctx):\r\n    await ctx.send(\"Shutting down the bot\")\r\n    return await client.logout()  # this just shuts down the bot.\r\n\r\n\r\n# looping every day\r\n# change parameter to minutes=1 and see it happen every minute\r\n@tasks.loop(minutes=1)\r\nasync def notification_loop():\r\n    if not SCHEDULED_HOURS:\r\n        return\r\n\r\n    # print(\"called_once_a_day:\")\r\n    async def send_notifications():\r\n        # print(datetime.datetime.now().hour)\r\n        message_channel = client.get_channel(channelID)\r\n        dates = BS_UTILS.get_dict_of_discussion_dates()\r\n        # dates = DATES\r\n        string = BS_UTILS.find_upcoming_disc_dates(1, dates)\r\n        string += BS_UTILS.get_notifications_past_24h()\r\n\r\n        # print(\"str: \", string)\r\n        if len(string) == 0:\r\n            ## only for debugging ##\r\n            string = \"No posts today\"\r\n        # send the upcoming discussion due dates\r\n        await message_channel.send(string)\r\n        return\r\n\r\n    for s_hour in SCHEDULED_HOURS:\r\n        now = datetime.datetime.now()\r\n        next_notification = datetime.datetime.combine(now.date(), s_hour)\r\n        if next_notification.hour == now.hour and next_notification.minute == now.minute:\r\n            await send_notifications()\r\n\r\n\r\n# TODO: stop notifying immediately after running program.\r\n@notification_loop.before_loop\r\nasync def notification_before():\r\n    await client.wait_until_ready()\r\n\r\n\r\nnotification_loop.start()\r\n\r\n\r\n# This is our input stream for our discord bot\r\n# Every message that comes from the chat server will go through here\r\n@client.event\r\nasync def on_message(message):\r\n    global SCHEDULED_HOURS\r\n    # this message will be every single message that enters the server\r\n    # currently saving this info so its easier for us to debug\r\n    username = str(message.author).split('#')[0]\r\n    user_message = str(message.content)\r\n    channel = str(message.channel.name)\r\n    print(f'{username}: {user_message} ({channel}) ({message.channel.id})')\r\n\r\n    # just so that bot does not respond back to itself\r\n    if message.author == client.user:\r\n        return\r\n\r\n    # test gate to prevent multiple responses from the bot to the user\r\n    # guild_members = message.guild.members\r\n    # if message.author not in guild_members:\r\n    #    return\r\n\r\n    # Lets say that we want the bot to only respond to a specific text channel in a server named 'todo'\r\n    if message.channel.name == 'specifics':\r\n        if user_message.lower() == 'im bored':\r\n            await message.channel.send(\"You should probably study...\")\r\n            return\r\n\r\n    # setting up a basic 'hello' command so you get this gist of it\r\n    if user_message.lower() == 'hello':\r\n        # put your custom message here for the bot to output\r\n        # we would incorporate our chat module here and then craft an appropriate response\r\n        await message.channel.send(f'Hello {username}!')\r\n        return\r\n    elif user_message.lower() == 'bye':\r\n        await message.channel.send(f'Bye {username}!')\r\n        return\r\n    # get the current storage path\r\n    elif user_message.lower() == 'current storage location':\r\n        # todo: access database and get the actual value\r\n\r\n        storage_path = DB_UTILS._mysql.general_command(\"SELECT STORAGE_PATH from USERS WHERE FIRST_NAME = 'Raveena';\")\r\n        if storage_path[0][0] is None:\r\n            await message.channel.send('No storage path specified. Type update storage to save something')\r\n        else:\r\n            await message.channel.send(f'Current location: {storage_path[0][0]}')\r\n        return\r\n\r\n    # update the current storage path (used starts with so they can type update storage destination or path)\r\n    elif message.content.startswith('update storage'):\r\n        await message.channel.send(\"Google Drive or Local?\")\r\n\r\n        # check what type of path they want\r\n        def storage_path(m):\r\n            return m.author == message.author\r\n\r\n        # getting the type of storage location\r\n        try:\r\n            path_type = await client.wait_for('message', check=storage_path, timeout=30)\r\n        except asyncio.TimeoutError:\r\n            await message.channel.send(\"taking too long...\")\r\n            return\r\n\r\n        # checking what type of path they are going to save it in\r\n        if path_type.content == \"google drive\":\r\n            await message.channel.send(\"What folder from root?\")\r\n            # checking to see if path is valid\r\n            try:\r\n                new_storage = await client.wait_for('message', check=storage_path, timeout=30)\r\n                drive = init_google_auths()\r\n                return_val = validate_path_drive(new_storage.content, drive)\r\n                if not return_val:\r\n                    await message.channel.send(\"Not a valid path. Try the cycle again.\")\r\n                else:\r\n                    # todo add saving mechanism to cloud database\r\n                    sql_type = \"UPDATE USERS SET Storage_method = '{path_type}' WHERE first_name = '{f_name}';\" \\\r\n                        .format(path_type=\"GDRIVE\", f_name=username.split(\" \")[0])\r\n                    DB_UTILS._mysql.general_command(sql_type)\r\n                    sql_path = \"UPDATE USERS SET Storage_path = '{path}' WHERE first_name = '{f_name}';\" \\\r\n                        .format(path=new_storage.content, f_name=username.split(\" \")[0])\r\n                    DB_UTILS._mysql.general_command(sql_path)\r\n\r\n                    await message.channel.send(\"New path saved\")\r\n                return\r\n            except asyncio.TimeoutError:\r\n                await message.channel.send(\"taking too long...\")\r\n\r\n        # if the path is local\r\n        elif path_type.content == \"local\":\r\n            await message.channel.send(\"Send your local path\")\r\n            # checking to see if path is valid (local)\r\n            try:\r\n                new_storage = await client.wait_for('message', check=storage_path, timeout=30)\r\n                return_val = validate_path_local(new_storage.content)\r\n                if not return_val:\r\n                    await message.channel.send(\"Not a valid path. Try the cycle again.\")\r\n                else:\r\n                    # todo add saving mechanism to cloud database\r\n                    sql_type = \"UPDATE USERS SET Storage_method = '{path_type}' WHERE first_name = '{f_name}';\" \\\r\n                        .format(path_type=\"LOCAL\", f_name=username.split(\" \")[0])\r\n                    DB_UTILS._mysql.general_command(sql_type)\r\n                    sql_path = \"UPDATE USERS SET Storage_path = '{path}' WHERE first_name = '{f_name}';\" \\\r\n                        .format(path=new_storage.content, f_name=username.split(\" \")[0])\r\n                    DB_UTILS._mysql.general_command(sql_path)\r\n                    await message.channel.send(\"New path saved\")\r\n                return\r\n            except asyncio.TimeoutError:\r\n                await message.channel.send(\"taking too long...\")\r\n\r\n        else:\r\n            await message.channel.send(\"Your input isn't valid\")\r\n\r\n\r\n    # get a grade for a class\r\n    elif message.content.startswith(\"grades:\"):\r\n        courses = message.content.split(\":\")[1].split(\",\")\r\n        IDs = []\r\n        for c in courses:\r\n            course_id = BS_UTILS.find_course_id(c)\r\n            IDs.append(course_id)\r\n        print(IDs)\r\n\r\n        grades = {}\r\n        counter = 0\r\n        for i in IDs:\r\n            if i == -1:\r\n                grades[courses[counter]] = 'Not found'\r\n            else:\r\n                fraction_string, percentage = BS_UTILS._bsapi.get_grade(i)\r\n                print(fraction_string)\r\n                print(percentage)\r\n                if len(fraction_string) <= 1:\r\n                    grades[courses[counter]] = 'Not found'\r\n                else:\r\n                    letter = BS_UTILS.get_letter_grade(percentage)\r\n                    grades[courses[counter]] = letter\r\n            counter = counter + 1\r\n\r\n        print(grades)\r\n        grades = dict(sorted(grades.items(), key=lambda item: item[1]))\r\n        print(grades)\r\n        final_string = \"Your grades are: \\n\"\r\n        for key, value in grades.items():\r\n            final_string = final_string + key.upper() + \": \" + value + \"\\n\"\r\n\r\n        await message.channel.send(final_string)\r\n        return\r\n\r\n    # get feedback on assignment.\r\n    elif message.content.startswith(\"get assignment feedback\"):\r\n        await message.channel.send(\"Please provide the Course name (for ex, NUTR 303) \\n\")\r\n\r\n        def author_check(m):\r\n            return m.author == message.author\r\n\r\n        course_name = await client.wait_for('message', check=author_check)\r\n        await message.channel.send(\"Please provide the full assignment name (for ex, 'Recitation Assignment 1')\\n\")\r\n        assignment_name = await client.wait_for('message', check=author_check)\r\n        feedback = BS_UTILS.get_assignment_feedback(course_name, assignment_name)\r\n        return\r\n\r\n    # get upcoming quizzes across all classes\r\n    elif message.content.startswith(\"get upcoming quizzes\"):\r\n        upcoming_quizzes = BS_UTILS.get_upcoming_quizzes()\r\n        # if there are no upcoming quizzes returned, then we report to the user.\r\n        if not upcoming_quizzes:\r\n            await message.channel.send(\"You have no upcoming quizzes or exams.\")\r\n            return\r\n        else:\r\n            await message.channel.send(\"You have the following upcoming assessments:\\n\")\r\n            for quiz in upcoming_quizzes:\r\n                course_name = quiz\r\n                current_quiz = upcoming_quizzes[quiz]\r\n                current_quiz_name = current_quiz[\"Name\"]\r\n                current_quiz_due_date = current_quiz[\"DueDate\"]\r\n                output_str = course_name + \" - \" + current_quiz_name + \" due \" + current_quiz_due_date + \"\\n\"\r\n                await message.channel.send(output_str)\r\n            return\r\n\r\n    elif message.content.startswith(\"get busiest weeks\"):\r\n        bs_utils = BSUtilities()\r\n        bs_utils.set_session(USERNAME, PIN)\r\n\r\n    elif message.content.startswith(\"get newly graded assignments\"):\r\n        await message.channel.send(\"Authorizing...\")\r\n        bs_utils = BSUtilities()\r\n        bs_utils.set_session(USERNAME, PIN)\r\n        await message.channel.send(\"Retrieving grades...\")\r\n        grade_updates = bs_utils.get_grade_updates()\r\n        # if there are no grade updates returned, then we report to the user.\r\n        if len(grade_updates) == 0:\r\n            await message.channel.send(\"You have no new grade updates.\")\r\n            return\r\n        else:\r\n            await message.channel.send(\"The following assignments have been graded:\\n\")\r\n            for grade in grade_updates:\r\n                output_str = \"Course Id:\" + str(grade['course_id']) + \"- \" + grade['assignment_name'] + \" \" + grade[\r\n                    'grade'] + \"\\n\"\r\n                await message.channel.send(output_str)\r\n            return\r\n\r\n    # changing bot name\r\n    elif message.content.startswith(\"change bot name\"):\r\n\r\n        # change value used to check if the user keep wants to change the name of the bot\r\n        # initialized to True\r\n\r\n        change = True\r\n        valid_change_response = True\r\n\r\n        # check method for waiting client's reply back\r\n        def check(msg):\r\n            return msg.author == message.author\r\n\r\n        while change:\r\n            # ask the user to which name they want to change\r\n            await message.channel.send(\"To which name do you want to change?\")\r\n\r\n            # get reply back from the user for bot's name\r\n            try:\r\n                new_name = await client.wait_for('message', check=check)\r\n            except asyncio.TimeoutError:\r\n                await message.channel.send(\"Timeout ERROR has occurred. Please try the query again.\")\r\n                return\r\n\r\n            # name changed message.\r\n            await message.guild.me.edit(nick=new_name.content)\r\n            await message.channel.send(\"My name is now changed!\")\r\n\r\n            # ask if the user wants to change the name again\r\n            await message.channel.send(\"Would you like to change my name again? Yes or No\")\r\n\r\n            # get reply back from the user if they want to change the bot name again.\r\n            try:\r\n                change_again = await client.wait_for('message', check=check)\r\n\r\n                # user does not want to change again\r\n                if change_again.content.startswith('No'):\r\n                    change = False\r\n                    await message.channel.send(\"Thank you for changing my name!\")\r\n                elif not change_again.content.startswith('Yes'):  # user input invalid response\r\n                    await message.channel.send(\"Invalid response given! Please try the query again.\")\r\n                    return\r\n            except asyncio.TimeoutError:\r\n                await message.channel.send(\"Timeout ERROR has occurred. Please try the query again.\")\r\n                return\r\n\r\n    elif message.content.startswith(\"upcoming discussion\"):\r\n        # dictionary of class_name, [list of dates]\r\n        dates = BS_UTILS.get_dict_of_discussion_dates()\r\n\r\n        # dates = DATES #ONLY FOR DEBUG\r\n        def check(msg):\r\n            return msg.author == message.author\r\n\r\n        # find discussion post deadline for 2 weeks\r\n        string = BS_UTILS.find_upcoming_disc_dates(14, dates)\r\n\r\n        if len(string) == 0:\r\n            await message.channel.send(\r\n                \"No upcoming posts for the next two weeks. Would you like to look further than 2 weeks?\")\r\n            try:\r\n                response = await client.wait_for('message', check=check, timeout=30)\r\n            except asyncio.TimeoutError:\r\n                await message.channel.send(\"taking too long...\")\r\n                return\r\n            # they want to see everything\r\n            if response.content.startswith(\"yes\"):\r\n                string = BS_UTILS.find_upcoming_disc_dates(0, dates)\r\n                if len(string) == 0:\r\n                    await message.channel.send(\"No upcoming posts.\")\r\n                else:\r\n                    await message.channel.send(string)\r\n                return\r\n            # don't want to see anything\r\n            else:\r\n                await message.channel.send(\"Okay, sounds good!\")\r\n                return\r\n        else:\r\n            await message.channel.send(string)\r\n            return\r\n\r\n    elif message.content.startswith(\"update schedule\"):\r\n        global SCHEDULED_HOURS\r\n\r\n        def check(msg):\r\n            return msg.author == message.author\r\n\r\n        async def recieve_response():\r\n            try:\r\n                res = await client.wait_for('message', check=check)\r\n            except asyncio.TimeoutError:\r\n                await message.channel.send(\"Timed out.\")\r\n                return None\r\n            return res\r\n\r\n        async def request_username():\r\n            await message.channel.send(\"What is your username?\")\r\n            username = await recieve_response()\r\n            author_id_to_username_map[username.author.id] = username.content\r\n\r\n        async def naive_change():\r\n\r\n            while True:\r\n                await message.channel.send(\"What time? (e.g. 09: 12, 10:00, 23:24)\")\r\n\r\n                new_time = await recieve_response()\r\n                if not new_time:\r\n                    return\r\n\r\n                try:\r\n                    h = int(new_time.content[:2])\r\n                    m = int(new_time.content[3:])\r\n                except ValueError:\r\n                    await message.channel.send(\"Please re-enter your time as the format given.\")\r\n                    continue\r\n\r\n                if h < 0 or h > 23 or m < 0 or m > 59:\r\n                    await message.channel.send(\"Please re-enter your time as the format given.\")\r\n                    continue\r\n\r\n                new_hour = datetime.time(h, m, 0)\r\n                break\r\n\r\n            await message.channel.send(\r\n                f\"Do you want to add this time to your schedule, or you want notifications only for this time?\")\r\n            res = await recieve_response()\r\n\r\n            res = res.content\r\n            add = False\r\n            if \"add\" in res:\r\n                add = True\r\n\r\n            await message.channel.send(f\"{new_time.content}, right?\")\r\n            res = await recieve_response()\r\n\r\n            if res.content.startswith(\"y\") or res.content.startswith(\"right\"):\r\n                if res.author.id not in author_id_to_username_map:\r\n                    await request_username()\r\n\r\n                if add:\r\n                    print(author_id_to_username_map)\r\n                    DB_UTILS.add_notifictaion_schedule(author_id_to_username_map[res.author.id], new_time.content)\r\n                    # SCHEDULED_HOURS.append(new_hour)\r\n                else:\r\n                    SCHEDULED_HOURS = [new_hour]\r\n\r\n                await message.channel.send(f\"Schedule changed.\")\r\n            else:\r\n                await message.channel.send(f\"No changes are made to your schedule.\")\r\n\r\n        await naive_change()\r\n\r\n    elif message.content.startswith(\"check notification schedule\"):\r\n        if not SCHEDULED_HOURS:\r\n            await message.channel.send(\"No schedules now!\")\r\n        else:\r\n            msg = \"\"\r\n            for hour in SCHEDULED_HOURS:\r\n                msg += f\"{hour}\\n\"\r\n\r\n            await message.channel.send(msg)\r\n\r\n    elif message.content.startswith(\"download: \"):\r\n        course = message.content.split(\":\")[1]\r\n        storage_path = DB_UTILS._mysql.general_command(\"SELECT STORAGE_PATH from USERS WHERE FIRST_NAME = 'Raveena';\")\r\n        storage_type = DB_UTILS._mysql.general_command(\"SELECT STORAGE_METHOD from USERS WHERE FIRST_NAME = 'Raveena';\")\r\n        course_id = BS_UTILS.find_course_id(course)\r\n        if storage_path[0][0] is not None:\r\n            BS_UTILS.download_files(course_id, storage_path[0][0], storage_type[0][0])\r\n            await message.channel.send(\"Files downloaded successfully!\")\r\n            return\r\n        else:\r\n            await message.channel.send(\"Files not downloaded successfully\")\r\n            return\r\n\r\n    # returning user course priority by either grade or upcoming events\r\n    elif message.content.startswith(\"course priority\"):\r\n\r\n        def check(msg):\r\n            return msg.author == message.author\r\n\r\n        # ask user for pick grade or by due date\r\n        await message.channel.send(\"Please pick between grade or due dates for prioritizing your courses.\")\r\n\r\n        try:\r\n            priority_option = await client.wait_for('message', check=check)\r\n\r\n            if priority_option.content.startswith(\"grade\"):\r\n                # api call for grades\r\n                await message.channel.send(\"Setting course priority by grade ...\")\r\n\r\n                priority = BS_UTILS.get_sorted_grades()[0]\r\n                missing = BS_UTILS.get_sorted_grades()[1]\r\n\r\n                suggested_course_priority = \"\"\r\n                for x in range(0, len(priority)):\r\n                    suggested_course_priority += priority[x]\r\n                    if not x == len(priority) - 1:\r\n                        suggested_course_priority += \" >> \"\r\n\r\n                found_missing_grade_courses = \"\"\r\n                for x in range(0, len(missing)):\r\n                    found_missing_grade_courses += missing[x]\r\n                    if not x == len(missing) - 1:\r\n                        found_missing_grade_courses += \" , \"\r\n\r\n                await message.channel.send(\"The suggested course priority is:\\n\" + suggested_course_priority)\r\n                await message.channel.send(\"There are some courses that miss final grades:\\n\"\r\n                                           + found_missing_grade_courses)\r\n\r\n            elif priority_option.content.startswith(\"due dates\"):\r\n                # api call for due dates\r\n                await message.channel.send(\"Setting course priority by upcoming due dates ...\")\r\n\r\n\r\n\r\n                await message.channel.send(\"Sorry we are adjusting function at the moment, please try it next time\")\r\n            else:\r\n                await message.channel.send(\"Invalid response given! Please try the query again.\")\r\n                return\r\n\r\n        except asyncio.TimeoutError:\r\n            await message.channel.send(\"Timeout ERROR has occurred. Please try the query again.\")\r\n            return\r\n\r\n        return\r\n\r\n# Now to actually run the bot!\r\nclient.run(config['token'])\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/discord_bot.py b/discord_bot.py
--- a/discord_bot.py	
+++ b/discord_bot.py	
@@ -496,8 +496,6 @@
                 # api call for due dates
                 await message.channel.send("Setting course priority by upcoming due dates ...")
 
-
-
                 await message.channel.send("Sorry we are adjusting function at the moment, please try it next time")
             else:
                 await message.channel.send("Invalid response given! Please try the query again.")
